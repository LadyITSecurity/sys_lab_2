#include <iostream>#include <pthread.h>#include <unistd.h>#include <thread>#include <string>#include <ctime>inline void error(const char* file, int line) {    auto tmp = errno;//fprintf may fail, so we preserve errno    fprintf(stderr, "%s (line %d) :", file, line);    errno = tmp;    perror(NULL);    exit(EXIT_FAILURE);}inline int xcheck(int p, const char* file, int line) {    if (p < 0) error(file, line);    return p;}template<typename T>inline T* xcheck(T* p, const char* file, int line) {    if (p == nullptr) error(file, line);    return p;}#define check(x) xcheck(x, __FILE__, __LINE__ )class game_monitor {    static constexpr int NO_GUESS = -1;    volatile bool _answer = true;    volatile int _guess = NO_GUESS;    pthread_spinlock_t spin;public:    game_monitor(){        pthread_spin_init(&spin,0);    }    void set_guess(int new_guess) {        _guess = new_guess;    }    int get_guess() {        int g = NO_GUESS;        while (g == NO_GUESS) {            g = _guess;        };        return g;    }    void set_answer(bool answer) {        pthread_spin_lock(&spin);        _guess = NO_GUESS;        _answer = answer;        pthread_spin_unlock(&spin);    }    bool get_answer() {        int g = 0;        bool a;        while (g != NO_GUESS) {            pthread_spin_lock(&spin);            g = _guess;            a = _answer;            pthread_spin_unlock(&spin);        };        return a;    }    void start() {        set_answer(false);        //set_guess(true);    }    void wait_for_start() const{        while (_answer) {}    }};pthread_spinlock_t spin;void init_spinlock(){    pthread_spin_init(&spin,0);    return;}thread_local std::string thread_name;constexpr int MAX_VALUE = 10;int next_val() {    return rand() % MAX_VALUE;}void say(std::string what, void* spin) {    pthread_spinlock_t* tmp = (pthread_spinlock_t*)spin;    pthread_spin_lock(tmp);    std::cout << thread_name << ">>" << what << std::endl;    pthread_spin_unlock(tmp);}void sleep(int ms) {    timespec t{ .tv_sec = 0, .tv_nsec = ms * 1000000 };    nanosleep(&t, nullptr);}game_monitor g;struct args { std::string thread_name; };int guess_count = 0;void player1(void* spin) {    const int value = next_val();    say("My value is " + std::to_string(value), spin);    g.start();    bool answer = false;    while (!answer) {        int guess = g.get_guess();        answer = value == guess;        guess_count++;        say(answer ? "Right" : "Wrong", spin);        g.set_answer(answer);        sleep(250);    }}clock_t start, end;void player2(void* spin) {    g.wait_for_start();    bool answer = false;    while (!answer) {        int guess = next_val();        say("My guess is " + std::to_string(guess), spin);        g.set_guess(guess);        answer = g.get_answer();        sleep(250);    }    say("I won :)", spin);    end = clock();    std::cout << "\t\tGame time: " << ((float)end-start)/ (float) CLOCKS_PER_SEC << std::endl;    std::cout << "\t\tGuess count: "  << guess_count << "\n" << std::endl;    guess_count = 0;}constexpr int MAX_GAMES = 11;void next_game(bool f, int i, void* spin) {    if (i >= MAX_GAMES)        return;    if (f)        player1(spin);    else        player2(spin);    next_game(!f, ++i, spin);}void game(std::string name, bool f, void* spin) {    thread_name = std::move(name);    next_game(f, 0, spin);}void* thread2_game(void* spin){    game("Thread2", false, spin);    return NULL;}int main(){    pthread_t t;    pthread_spinlock_t spin;    pthread_spin_init(&spin,0);    //args arg = {"Thread2"};    check(pthread_create(&t, NULL, thread2_game, (void*)&spin));    game("Thread1", true, (void*)&spin);    void* result;    pthread_join(t, &result);    std::cout << "Thread return code: " << result;}